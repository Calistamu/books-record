# 《软件工程》自我学习

## 第1篇 软件工程与软件过程
### 第一章 软件工程概述

   软件生命周期过程：定义、实现、评估、管理、变更、改进。  
   
   软件配置：程序（能够完成预定功能和性能的可执行的指令序列）、文档（开发、使用、维护程序所需要的图文资料）、数据（使程序能够适当地处理信息的数据结构）  
   
   软件工程学：提高软件的可维护性，减少软件维护的代价。  
   
   软件工程是开发、运行、维护和修复软件的系统方法。  

   软件危机：计算机软件的开发和维护过程中所遇到的一系列严重问题。  
   软件危机包括：1.如何开发软件，以满足对软件日益增长的需求2.如何维护数量不断膨胀的已有软件。

   软件工程三要素：方法、工具和过程

## 第2篇 传统方法学
### 第二章 软件过程

   软件生命周期：软件定义、软件开发、运行维护。  
   
   生命周期模型：规定了把生命周期划分成哪些阶段及各个阶段的执行顺序。也称过程模型。

   瀑布模型：最广泛的过程模型。收集需求--分析--设计--编码--测试--维护。实际的瀑布模型是反馈环的，因为不可能不出错。  
   优点：强迫使用规范的方法（如结构化技术），严格规定了每个阶段必须提交的文档，要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。  
   缺点：文档驱动的模型，很难全面正确地认识动态的软件产品。

   快速原型：快速建立起来的可以在计算机上运行的程序，所能完成的功能往往是最终产品能完成的功能的子集。  
   快速原型模型:快速建立一个能反应用户主要需求的原型系统，让用户在计算机上试用它，通过实践来了解系统的概貌。不带反馈环。收集需求--快速原型--构建--移交部署。  
   优点：软件产品的开发基本上是按线性顺序进行的。快速。  

   增量模型：渐增模型。分析--设计--编码--测试。分批逐步向用户提交产品，每一次提交一个满足用户需求子集的可运行的产品。  
   优点：能在较短时间内向用户提交可完成一些有用的工作的产品，逐步增加产品功能可以使用户有充裕的时间学习和适应新产品。  
   缺点：新的增量构件集成到现有软件体系结构中，必须不破坏原来已经开发出的产品。

   螺旋模型：每个阶段之前都增加了风险分析的快速原型模型。
   优点：对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标，减少了过多测试或测试不足所带来的风险，在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没有本质区别。适用于内部开发的大规模软件项目。  
   缺点：风险驱动。

   喷泉模型 要避免过分无序，应该把一个线性过程作为总目标 迭代和无缝

   Rational统一过程（RUP）软件开发过程框架 迭代和渐增式开发

   敏捷过程与极限编程：个体与交互很重要，把好的开发时间运用到极致

   能力成熟度模型CMM：改进软件过程的一种策略，并不是一个如软件生命周期。包括：成熟度等级、过程能力、关键过程域、目标、公共特性、关键实践。能力成熟度等级：初始级、可重复级、已定义级、已管理级、优化级。关键过程域：达到一个成熟度等级的必要条件。

### 第三章 传统方法学
  
   结构化分析SA来完成需求分析。

   分析建模与规格说明---基本目标：1.描述用户的需求2.为软件设计工作奠定基础3.定义一组需求，一旦开发出软件产品之后，就可以用这组需求为标准来验收。分析建模的核心是数字字典，还包括实体-关系图（描述数据对象之间的关系），数据流图（进行处理规格说明），状态转换图（指明外部事件结果的系统行为）。软件需求规格说明有框架。

   实体-关系图

   数据流图

   状态转换图

   数字字典

   结构化分析三阶段：问题定义、可行性研究、需求分析。需求分析的主要任务是更详尽地定义系统应该完成的每一个逻辑功能。

### 第四章 结构化设计

   耦合：衡量不同模块彼此间相互依赖的紧密程度。数据耦合、控制耦合、特征耦合、公共环境耦合、内容耦合。尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合。

   内聚：衡量一个模块内部各个元素彼此结合的紧密程度。偶然内聚、逻辑内聚、时间内聚、过程内聚、通信内聚、顺序内聚、功能内聚。

   深度：软件结构中控制的层数。

   宽度：软件结构内同一个层次上的模块总数的最大值。
   
   扇出：一个模块直接控制（调用）的模块数目，扇出过大意味着模块过分复杂，需要控制和协调过多的下级模块，扇出过小也不好。

   扇入：表明有多少个上级模块直接调用它。

   层次图和HIPO图（左边框列出输入数据，中间主要的处理，右边产生的输出）

   变换流和数据流
   * 一个系统中的所有信息流都可以认为是变换流。数据流不具有显著的事务特点，最好使用变换分析。如果具有明显的事务中心，应采用事务分析技术。

   过程设计基本决定了最终的程序代码的质量。
   * 过程设计工具：程序流程图、盒图（N-S图）、PAD图、判定表、判定树、过程设计语言
   
   Jackson图

### 第五章 结构化实现
   黑盒测试：功能测试，在程序接口进行的测试，检查程序功能是否能按照规格说明书的规定正常使用，程序是否能适当地接收输入数据产生的输出信息，并且保持外部信息的完整性。技术：等价划分、边界值分析、、错误推测。  
   白盒测试：结构测试，完全了解程序的结构和处理过程，按照程序内部的逻辑测试程序，检验程序中的每条通路是否都能按预定要求正确工作。技术：逻辑覆盖、基本路径测试、条件测试、数据流测试。

   测试：单元测尺、集成测试、确认测试、系统测试。

## 第3篇 面向对象方法学
### 第六章 面向对象方法学导论
开发软件三种模型：对象模型、动态模型、功能模型。

面向对象的设计方法：以算法为核心，把数据和处理过程作为相互独立的部分，数据代表问题域中地实体，而程序代码则用于处理这些数据。

面向对象=对象+类+继承+通信

### 第七章 面向对象分析

面对对象建模模型三要素：静态结构（对象模型）、交互次序（动态模型）、数据变换（功能模型）。

复杂问题地对象模型五个层次：主题曾、类与对象层、结构层、属性层、服务层。

### 第八章 面向对象设计

控制线：一条遍及状态图集合的路径，在这条路径上每次只有一个对象是活动的。

### 第九章 面向对象实现

集成测试：基于线程和基于使用。

测试类时使用的方法：随机测试、划分测试、基于故障的测试。

### 第十章 统一建模语言

UML：书写软件蓝图的标准语言。UML五类图：用例图、静态图、行为图、交互图、实现图。

所有的系统都可以从两个方面描述：静态结构和动态行为，类图用于描述静态结构，状态图、顺序图、协作图、活动图适于描述系统的动态行为。

物理架构用图建模，其中构件图显示代码本身的静态结构，部署图显示系统运行时的结构，这两个图也属于UML的图。

## 第4篇 软件项目管理
### 第十一章 计划

度量软件规模  
1. 代码行技术：简单的定量估算软件规模的方法。
* 有公式L=（a平均值+4m平均值+b平均值）/6，LOC代码行数
2. 功能点技术
* 信息域：输入项数Inp、输出项数Out、查询数Inq、主文件数Maf、外部接口数Inf  
* 计算步骤：   
  1.未调整功能点数UFP=a1xInp+a2xOut+a3xInq+a4xMaf+a5xInf(ai信息域特性系数)  
  2.技术复杂性因子TCF  
  3.功能点数FP=UFPxTCF
* 与编程语言无关，但较主观

工作量估算
1. 静态单变量模型
* 不同的估算模型公式不同
2. 动态多变量模型（软件方程式）：软件规模和开发时间这两个变量的函数
3. COCOMO2模型（构造性成本模型）
* 三层次估算模型

Brooks规律：向一个已经延期的项目增加人力，只会使得它更加延期。

进度计划工具：Gantt图和工程网络。
* 工程网络显式地定义事件及作业之间的依赖关系，Gantt图只能隐含地表示这种关系。

### 第十二章 组织

讲了组织方式

### 第十三章 控制

基线

软件配置五项任务：标识、版本控制、变化控制、配置审计、状态报告。 

### 第十四章 软件维护与软件文档
软件维护:纠错性维护、适应性维护、完善性维护、预防性维护。
## 第5篇 高级课程
### 第十五章 形式化方法
软件工程方法：非形式化、半形式化、形式化。

Petri网：用于确定系统中隐含的定时问题，它也可以用于设计中。

Z语言：形式化规格说明语言之一。
### 第十六章 软件重用
重用包括领域工程和软件工程。  
领域工程：分析、构造、传播。

### 总结
概念性内容，较为抽象，与实际理解时有时困难，因为想不通要怎么去实现。对于软件开发和工程，有了一些新的见解，还是太浅薄，不深刻。